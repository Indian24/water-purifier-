You are an expert full-stack engineer. Implement a complete, production-grade user registration and login system for a web app. Follow these exact functional, security, and UX requirements. Deliver code, database migration, API docs (OpenAPI/Swagger preferred), tests, and minimal frontend integration examples. Use sensible defaults (Node.js + Express + PostgreSQL) unless I specify another stack — but structure the prompt so you can swap to Django/Flask/.NET if asked.

GOAL
- Register users with phone number (primary) and optional email. Phone is required and must be unique. Email is optional but if provided must be unique.
- Login using either phone+password or email+password (email only works if user provided it at registration).
- Persist users into the database. Use the same phone/email as the authentication identifier (primary/unique keys).
- Use one password (hashed) and session/auth token for login (JWT or server sessions).
- Provide secure endpoints for register, login, get current user, logout, and password reset flow.
- Provide small frontend form behaviors (validation, disable/enable submit) and examples for integrating with backend.

NON-FUNCTIONAL RULES (must follow)
1. Do not store plaintext passwords. Use bcrypt (or Argon2) with recommended parameters.
2. Use E.164 normalized phone numbers (validate/format).
3. Use HTTPS-only secure cookies for sessions OR JWT stored in httpOnly cookie. Explain tradeoffs.
4. Rate limit authentication endpoints and add brute-force protection (e.g., account lockout or exponential backoff).
5. Log minimal info — never log passwords.
6. Return clear, non-leaking error messages for auth failures (e.g., "invalid credentials" vs "user not found").
7. Validate inputs server-side and client-side.
8. Add unit/integration tests for happy & error paths (register, duplicate phone/email, login success/failure, missing required fields).

DATABASE SCHEMA (SQL)
- Implement a `users` table with at least the following fields:

CREATE TABLE users (
id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
phone VARCHAR(25) NOT NULL UNIQUE, -- normalized E.164
phone_verified BOOLEAN NOT NULL DEFAULT FALSE,
email VARCHAR(255) UNIQUE, -- nullable
email_verified BOOLEAN NOT NULL DEFAULT FALSE,
password_hash TEXT NOT NULL,
full_name VARCHAR(255),
created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);


- Add indexes on `phone` and `email`.
- If using MySQL or other DB, adapt types accordingly.

VALIDATION RULES
- phone: required, E.164 formatting, unique. Reject obviously invalid numbers.
- email: optional, RFC-compliant validation if present, unique.
- password: required, minimum 8 characters, at least one uppercase OR number OR symbol (configurable). Accept stronger policies.
- confirm_password: must match password in frontend before sending.
- full_name: optional but recommended.
- Ensure `at least one identifier` rule is satisfied (phone required in this spec).

API SPEC (RESTful) — Return JSON. Use status codes properly.

1) POST /api/auth/register
- Request JSON:
  {
    "full_name": "Manish Ranjan",
    "phone": "+918700762477",
    "email": "ranjanmanish516@gmail.com",   // optional
    "password": "StrongPassword!",
    "confirm_password": "StrongPassword!"
  }
- Behavior:
  - Normalize phone to E.164.
  - Validate inputs.
  - If `phone` already exists -> 409 Conflict { error: "Phone already registered" }.
  - If `email` provided and exists -> 409 Conflict { error: "Email already registered" }.
  - Hash password, insert user, return 201 Created with minimal user data (id, phone, email, created_at).
  - Optionally send verification OTP/email (implement as configurable — deliver stub or demo).
  - Do NOT return password or hash.

2) POST /api/auth/login
- Request JSON:
  {
    "identifier": "+918700762477",   // could be phone or email
    "password": "StrongPassword!"
  }
- Behavior:
  - Detect if identifier is phone (E.164) or email (looks like email).
  - Find user by phone or email. If not found or password mismatch -> 401 { error: "Invalid credentials" }.
  - If found, issue JWT token (short-lived access + refresh flow if implemented) OR set httpOnly secure cookie.
  - Return 200 { token: "...", user: { id, phone, email, full_name } } OR return empty body and set cookie.
  - Include role/claims if required later.

3) GET /api/auth/me
- Auth required. Returns the current authenticated user (id, phone, email, full_name, created_at).

4) POST /api/auth/logout
- Clear session or invalidate refresh token.

5) POST /api/auth/request-password-reset
- Accept phone OR email as identifier. Send OTP/email token. (Implementation can be mocked/console if mail/SMS not available.)

6) POST /api/auth/reset-password
- Accept reset token + new password. Validate and update hashed password.

SECURITY & IMPLEMENTATION DETAILS
- Password hashing: bcrypt with cost 12 (or Argon2 defaults). Explain why and allow config.
- Token: JWT signed with a server secret (HS256) and short expiry for access (e.g., 15m), and refresh token lifecycle if used. Store refresh tokens in DB to allow revocation.
- Cookies: Use `Set-Cookie` with `Secure; HttpOnly; SameSite=Strict` for session cookie.
- Rate limiting: e.g., 100 req/hr global; 10 login attempts per 15min per IP + per account.
- Brute-force: On 5 failed attempts for an account lock for 15 min (configurable), notify user via email/SMS if available.
- Data encryption at rest: recommend DB encryption for sensitive fields where possible.
- Phone verification: implement OTP flow (6-digit) via SMS provider (Twilio/other). If provider not provided, implement pluggable interface and fallback to logging the OTP in server logs for dev.
- Email verification: send verification link with token TTL.

FRONTEND FORM BEHAVIOR (HTML/JS)
- Registration form fields: full_name, phone (required), email (optional), password, confirm_password.
- Client validations:
  - phone required and normalized on blur using libphonenumber-js.
  - if phone invalid -> show inline error and disable submit.
  - password confirmations checked client-side.
  - disable submit until validations pass.
  - show server errors returned by API.
- Login form: identifier (phone or email), password. Allow user to type phone or email; detect type visually.
- After successful login, store token ONLY in httpOnly cookie or in-memory (not localStorage if using JWT).
- If using SPA, refresh token flow should be implemented to avoid logout on page refresh.

EXAMPLES (cURL)
- Registration:
curl -X POST https://api.example.com/api/auth/register
-H "Content-Type: application/json"
-d '{"full_name":"Manish Ranjan","phone":"+918700762477","email":"ranjanmanish516@gmail.com","password":"MyPassw0rd!","confirm_password":"MyPassw0rd!"}'

- Login:
curl -X POST https://api.example.com/api/auth/login
-H "Content-Type: application/json"
-d '{"identifier":"+918700762477","password":"MyPassw0rd!"}'


TESTING & ACCEPTANCE CRITERIA
- Unit tests for:
  - successful registration
  - registration fails for duplicate phone
  - registration fails for duplicate email
  - login success by phone
  - login success by email (if provided)
  - login fails with incorrect password
  - password reset flow
- Integration test that registers a user, logs in, calls `/api/auth/me`.
- Manual test checklist:
  - Register with valid phone and no email -> success.
  - Register with valid phone and email -> success.
  - Register with phone that already exists -> 409.
  - Login with phone+password -> 200 and token cookie set.
  - Login with email+password -> 200 (only if email present).
  - Logout invalidates session.
  - Attempt more than allowed login attempts -> account temporarily locked.

DELIVERABLES (what I expect from the AI/dev)
1. Backend code implementing API endpoints (with README for setup).
2. Database migration / SQL script.
3. OpenAPI/Swagger file describing endpoints and schemas.
4. Minimal frontend form (React or plain HTML/JS) demonstrating register & login flows.
5. Unit & integration tests + instructions to run them.
6. A short security checklist and how to configure OTP provider and email provider.

EDGE CASES & NOTES
- If a user registers by phone only, they may later add / verify an email. Support an endpoint to update profile including adding email (with verification).
- Make phone the canonical unique login key. If later email is added, allow login by email as well.
- When designing foreign keys (e.g., other tables referencing `users`), use `users.id` (UUID) as FK — do not use phone/email as FK in other tables.
- If asked, provide code stubs for other stacks (.NET Core, Django) following the same schema & behavior.

IMPLEMENTATION PRIORITY (what to build first)
1. DB schema + migration.
2. Register endpoint + server validation + hashing + duplicate checks.
3. Login endpoint + token issuance + cookie/session management.
4. `/me` endpoint.
5. Frontend forms with client validation.
6. Password reset & verification flows.
7. Tests + docs + rate limiting + brute force protection.

If implementing this, produce a single runnable repository with:
- README with setup steps (DB, env vars for JWT secret and OTP/email providers).
- `docker-compose.yml` (optional) to run DB and app for quick demo.
- Postman/Insomnia collection or exported curl examples.

Finally, include a brief section called "How to switch to using email as primary instead of phone" that lists the DB & API changes required.

Make the implementation configurable via environment variables:
- `AUTH_PREFER_PHONE=true` (default true)
- `JWT_SECRET`, `JWT_ACCESS_EXP`, `JWT_REFRESH_EXP`
- `OTP_PROVIDER`, `EMAIL_PROVIDER`

Deliver the code and docs. If any provider keys are needed, implement provider adapter interfaces and provide stubs that print OTPs to server log for local development.

--- End of prompt to execute.